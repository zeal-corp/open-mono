(self.webpackChunkblog=self.webpackChunkblog||[]).push([[931],{2288:function(e,t,a){"use strict";var n=a(3289),o=a(430),i=a.n(o),s={startOnLoad:!0,logLevel:"fatal",securityLevel:"strict",arrowMarkerAbsolute:!1,flowchart:{htmlLabels:!0,curve:"linear"},sequence:{diagramMarginX:50,diagramMarginY:10,actorMargin:50,width:150,height:65,boxMargin:10,boxTextMargin:5,noteMargin:10,messageMargin:35,mirrorActors:!0,bottomMarginAdj:1,useMaxWidth:!0,rightAngles:!1,showSequenceNumbers:!0,fontFamily:'"Jet Brains Mono", "sans-serif"'},themeVariables:{lineColor:"#ffffff",textColor:"#ffffff",primaryColor:"#ffffff"}};t.Z=function(e){var t=e.name,a=e.chart,o=e.config;return i().initialize(Object.assign({},s,o)),(0,n.useEffect)((function(){i().contentLoaded()})),a?n.createElement("div",{className:"mermaid",name:t},a):null}},1703:function(e,t,a){"use strict";a.r(t),a.d(t,{frontMatter:function(){return l},metadata:function(){return p},toc:function(){return c},chart:function(){return d},default:function(){return m}});var n=a(2),o=a(189),i=(a(3289),a(7081)),s=a(2288),r=["components"],l={},p={unversionedId:"posts/testing-at-zeal",id:"posts/testing-at-zeal",isDocsHomePage:!1,title:"how zeal writes and runs tests",description:"overview",source:"@site/docs/posts/testing-at-zeal.mdx",sourceDirName:"posts",slug:"/posts/testing-at-zeal",permalink:"/open-mono/docs/posts/testing-at-zeal",editUrl:"https://github.com/zeal-corp/open-mono/edit/main/blog/docs/posts/testing-at-zeal.mdx",version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"test lifecycle",permalink:"/open-mono/docs/posts/test-lifecycle"}},c=[{value:"overview",id:"overview",children:[]},{value:"naming",id:"naming",children:[]},{value:"tech",id:"tech",children:[]},{value:"approach",id:"approach",children:[]},{value:"selectors",id:"selectors",children:[]},{value:"methods",id:"methods",children:[]},{value:"use in a test",id:"use-in-a-test",children:[]},{value:"pom to DOM",id:"pom-to-dom",children:[]}],d="sequenceDiagram\n    participant G as GitHub\n    participant J as Jenkins\n    participant E as Executor\n    G->>J: A new MR has been opened!\n    J->>G: Great, where is my script to run?\n    G->>J: Here it is, '<some-flippin-path>.gvy'!\n    J->>E: Please run this script and tell me what happens.\n    E->>J: Here is the result of running that script!\n    J->>G: Here is your red 'x' buddy! (occasional success can occurr)\n",u={toc:c,chart:d};function m(e){var t=e.components,a=(0,o.Z)(e,r);return(0,i.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"overview"},"overview"),(0,i.kt)("p",null,"at zeal we are big proponents of the ",(0,i.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Monorepo"},"mono-repo"),", and with it the simplified process of running ",(0,i.kt)("a",{parentName:"p",href:"https://www.browserstack.com/guide/end-to-end-testing"},"e2e")," tests on a per commit/per deploy basis. when we began planning for including a set of e2e tests, we wanted to be very intentional about setup and running of our tests. in the end we landed on a few techs and approaches, but first we want to diagram our standard pull request flow, so we can make clear where we want to run these tests, and when/how often they need to be run:"),(0,i.kt)(s.Z,{chart:d,mdxType:"Mermaid"}),(0,i.kt)("h2",{id:"naming"},"naming"),(0,i.kt)("p",null,"as important as the code itself is the ceremony of choosing a name. as a shop with a star trek ",(0,i.kt)("em",{parentName:"p"},"enthusiast")," skewed shop (meaning people allow my fandom and support it), we've been choosing specific character names for our packages. we ended up going with ",(0,i.kt)("inlineCode",{parentName:"p"},"weyoun")," a vorta administrator, to speak to weyoun's unwavering administrative oversight of our code quality."),(0,i.kt)("h2",{id:"tech"},"tech"),(0,i.kt)("p",null,"for testing, we wanted to continue to use a pure js stack, and so we took a look at various js packages, like ",(0,i.kt)("a",{parentName:"p",href:"https://www.selenium.dev/"},"selenium"),", ",(0,i.kt)("a",{parentName:"p",href:"https://www.cypress.io/"},"cypress"),", ",(0,i.kt)("a",{parentName:"p",href:"https://testcafe.io/"},"TestCafe"),", ",(0,i.kt)("a",{parentName:"p",href:"https://playwright.dev/"},"playwright"),", and more. in the end we wanted:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"stable tests, that run the same way each commit"),(0,i.kt)("li",{parentName:"ol"},"evergreen browser coverage, for multiple platforms"),(0,i.kt)("li",{parentName:"ol"},"decent docs with a stable long term support plan"),(0,i.kt)("li",{parentName:"ol"},"low devops overhead")),(0,i.kt)("p",null,"we these constraints in mind we ended up settling on ",(0,i.kt)("a",{parentName:"p",href:"https://playwright.dev/"},"playwright"),". it provieds the runners and drive connection, and it provides safari, edge, chrome, and firefox automation. the docs are very good, and with ",(0,i.kt)("a",{parentName:"p",href:"https://code.visualstudio.com/"},"vs code")," the ",(0,i.kt)("inlineCode",{parentName:"p"},"editor du jour"),", we feel far more confidence than we should in $MSFT's continued developer benevolence."),(0,i.kt)("h2",{id:"approach"},"approach"),(0,i.kt)("p",null,"after much ado about how to write tests, we landed on an approach; at the core of weyoun are ",(0,i.kt)("a",{parentName:"p",href:"https://playwright.dev/docs/pom"},"poms"),". poms provide an abstraction for testing. the core value of a pom:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the test is free from DOM specific configuration"),(0,i.kt)("li",{parentName:"ul"},"unifies the use of a single unit of the application"),(0,i.kt)("li",{parentName:"ul"},"allows all tests relying on one pom to be updated when it updates"),(0,i.kt)("li",{parentName:"ul"},"reduces cognitive load of mapping components to their tests")),(0,i.kt)("p",null,"let's show an example pom!"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:"title='weyoun/src/pom/login/index.ts'",title:"'weyoun/src/pom/login/index.ts'"},'import { Page } from "playwright";\nimport { Envs, getBaseUrl, getUser } from "../../utils";\n\nexport const LoginSelectors = {\n  email: "data-test-id=user-email",\n  password: "data-test-id=user-password",\n  submit: "data-test-id=user-submit",\n};\n\nexport class LoginPage {\n  page: Page;\n\n  constructor(page: Page) {\n    this.page = page;\n  }\n\n  async login(envOverride?: Envs): Promise<void> {\n    const user = getUser(envOverride);\n    await this.page.goto(`${getBaseUrl(envOverride)}/login`);\n    await this.page.fill(LoginSelectors.email, user.user);\n    await this.page.fill(LoginSelectors.password, user.password);\n    await this.page.click(LoginSelectors.submit);\n  }\n}\n')),(0,i.kt)("p",null,"let's dive in!"),(0,i.kt)("h2",{id:"selectors"},"selectors"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},'export const LoginSelectors = {\n  email: "data-test-id=user-email",\n  password: "data-test-id=user-password",\n  submit: "data-test-id=user-submit",\n};\n')),(0,i.kt)("p",null,"the selectors are how our pom interacts with the dom. we use ",(0,i.kt)("inlineCode",{parentName:"p"},"data-test-id")," for all of our clicking and interactions! using this means we can refactor a react component and as long as the data-test-id goes on the new interactive component the pom needs no updates!"),(0,i.kt)("p",null,"this separation also makes it clear to the developer exactly what the id is used for!"),(0,i.kt)("p",null,"you'll see our tests occasionally import a selector to handle some DOM check, this is a good pattern!"),(0,i.kt)("h2",{id:"methods"},"methods"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"  async login(envOverride?: Envs): Promise<void> {\n    const user = getUser(envOverride);\n    await this.page.goto(`${getBaseUrl(envOverride)}/login`);\n    await this.page.fill(LoginSelectors.email, user.user);\n    await this.page.fill(LoginSelectors.password, user.password);\n    await this.page.click(LoginSelectors.submit);\n  }\n")),(0,i.kt)("p",null,"this is a great example of a clean modular test section, it:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"uses a util to fetch a context aware user (the user know what env we are testing!)"),(0,i.kt)("li",{parentName:"ul"},"navigates to a url"),(0,i.kt)("li",{parentName:"ul"},"performs operations using the selectors, no internal selectors!"),(0,i.kt)("li",{parentName:"ul"},"performs a single clear unit of work")),(0,i.kt)("p",null,"this means this block is readable, extendable, and concise. these are the core tenets of useful and high quality poms!"),(0,i.kt)("h2",{id:"use-in-a-test"},"use in a test"),(0,i.kt)("p",null,"let's look at an example test:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'{9} title="weyoun/src/tests/smoke/login.spec.ts"',"{9}":!0,title:'"weyoun/src/tests/smoke/login.spec.ts"'},'import { Page } from "playwright";\nimport { LoginPage } from "../../pom/login";\nimport { AdminPage, AdminSelectors } from "../../pom/admin-page";\n\nconst page: Page = global.page;\n\ndescribe("login", () => {\n  test("login succeeds", async () => {\n    const loginPage = new LoginPage(page);\n    const adminPage = new AdminPage(page);\n    await loginPage.login();\n    await adminPage.isShowing();\n    const welcomePanel = await page.$(AdminSelectors.welcome);\n    expect(await welcomePanel.innerText()).toContain("Welcome");\n  });\n});\n')),(0,i.kt)("p",null,"you can see we create a new ",(0,i.kt)("inlineCode",{parentName:"p"},"LoginPage")," instance passing the global ",(0,i.kt)("inlineCode",{parentName:"p"},"page")," provided to us by ",(0,i.kt)("inlineCode",{parentName:"p"},"weyoun"),". if that sentence sounds like gibberish, please reread the ",(0,i.kt)("a",{parentName:"p",href:"./test-lifecycle"},"test lifecycle")," post again!"),(0,i.kt)("p",null,"after it's initialized we can simply ask for the page to ",(0,i.kt)("inlineCode",{parentName:"p"},"login"),". this makes the test very readable, concise, and easily reused."),(0,i.kt)("h2",{id:"pom-to-dom"},"pom to DOM"),(0,i.kt)("p",null,"this is the more complex part. when do you make a pom? how should they relate to the ui? fear not! i've got some basic guidelines:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"a react component should probably have a sibling POM"),(0,i.kt)("li",{parentName:"ul"},"a complex flow should be comprised of multiple smaller poms"),(0,i.kt)("li",{parentName:"ul"},"if you're adding vital functionality, make it testable!")),(0,i.kt)("p",null,"these rough guidelines should provide enough context for you to get going!"))}m.isMDXComponent=!0},5107:function(e,t,a){var n={"./locale":4138,"./locale.js":4138};function o(e){var t=i(e);return a(t)}function i(e){if(!a.o(n,e)){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}return n[e]}o.keys=function(){return Object.keys(n)},o.resolve=i,e.exports=o,o.id=5107}}]);